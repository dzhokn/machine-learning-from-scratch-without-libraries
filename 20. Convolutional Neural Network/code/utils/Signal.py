import numpy as np

class Signal:
    """
    Class for signal processing.
    It contains functions for correlation and convolution.
    """

    @staticmethod
    def convolve2d(image: np.ndarray, kernel: np.ndarray, mode: str = 'valid') -> np.ndarray:
        """
        Convolve the image with the kernel.
        """
        # Flip the kernel (after that it's a simple correlation)
        kernel = np.flip(kernel)
        return Signal.correlate2d(image, kernel, mode)

    @staticmethod
    def correlate2d(image: np.ndarray, kernel: np.ndarray, mode: str = 'valid') -> np.ndarray:
        """
        Compute the correlation of the image with the kernel.
        The correlation is a measure of how similar two signals are.
        In the context of image processing, the correlation is used to find the features in the image.
        The correlation is calculated by multiplying the kernel with the image cell by cell and summing the result.
        The output is a matrix of the same size as the image.
        The mode parameter determines the shape of the output matrix.
        - 'full' mode: the output matrix is the same size as the image.
        - 'valid' mode: the output matrix is the same size as the image minus the kernel size.

        Args:
            image (np.ndarray): The input image.
            kernel (np.ndarray): The kernel.
            mode (str): The mode of the correlation.

        Returns:
            np.ndarray: The output matrix.
        """
        # Get the shape of the kernel and image
        kernel_h, kernel_w = kernel.shape
        image_h, image_w = image.shape

        # CASE 1: Full mode - output shape is (y + m - 1, x + n - 1)
        if mode == 'valid':
            # Calculate the output shape
            output_h = image_h - kernel_h + 1
            output_w = image_w - kernel_w + 1
            # Calculate the output
            output = Signal.einsum_submatrices(image, kernel, output_h, output_w, kernel_h, kernel_w)
        # CASE 2: Valid mode - output shape is (y - m + 1, x - n + 1)
        elif mode == 'full':
            # Calculate the output shape
            output_h = image_h + kernel_h - 1
            output_w = image_w + kernel_w - 1
            # Add padding to the input image
            image = np.pad(image, ((kernel_h-1, kernel_h-1), (kernel_w-1, kernel_w-1)), mode='constant', constant_values=0)
            # Calculate the output
            output = Signal.einsum_submatrices(image, kernel, output_h, output_w, kernel_h, kernel_w)
        else:
            raise ValueError(f"Invalid mode: {mode}")
        return output

    def einsum_submatrices(image: np.ndarray, 
                           kernel: np.ndarray, 
                           output_h: int, 
                           output_w: int, 
                           kernel_h: int, 
                           kernel_w: int) -> np.ndarray:
        """
        Generate submatrices of the image in order to use np.einsum.
        The submatrices are generated by sliding the kernel over the image.
        The submatrices are then multiplied with the kernel and the result is summed.
        The result is a matrix of the same size as the image.

        Args:
            image (np.ndarray): The input image.
            kernel (np.ndarray): The kernel.
            output_h (int): The height of the output matrix.
            output_w (int): The width of the output matrix.
            kernel_h (int): The number of rows of the kernel.
            kernel_w (int): The number of columns of the kernel.

        Returns:

        """
        submatrices = []
        for i in range(output_h):
            for j in range(output_w):
                submatrices.append(image[i:i+kernel_h, j:j+kernel_w])
        submatrices = np.array(submatrices)
        submatrices = submatrices.reshape(output_h, output_w, kernel_h, kernel_w)
        # Multiply the submatrices with the kernel
        # np.einsum is a function that allows you to perform a dot product between two arrays.
        # It is a more efficient way to perform the dot product than using a for loop.
        # It is also more readable and concise.
        # Generate submatrices of the image in order to use np.einsum
        return np.einsum('ijkl,kl->ij', submatrices, kernel)